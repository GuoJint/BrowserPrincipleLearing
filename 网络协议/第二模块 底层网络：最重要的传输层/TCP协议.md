### TCP协议

#### TCP 包头格式
1. 首先，源端口号和目标端口号是不可少的，这一点和 UDP 是一样的。
2. 接下来是包的序号。为什么要给包编号呢？当然是为了解决乱序的问题。
3. 还应该有的就是确认序号。发出去的包应该有确认，要不然我怎么知道对方有没有收到呢？
4. 接下来有一些状态位。例如 SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。
5. 还有一个重要的就是窗口大小。TCP 要做流量控制，通信双方各声明一个窗口，标识自己当前能够的处理能力。
6. 除了做流量控制以外，TCP 还会做拥塞控制，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。

	顺序问题 ，稳重不乱；
	丢包问题，承诺靠谱；
	连接维护，有始有终；
	流量控制，把握分寸；
	拥塞控制，知进知退。
	
#### TCP 的三次握手
1. TCP三次握手的主要原因
解决TCP 包的序号的问题
	- 为什么需要tcp包序号：如果tcp包序号都以1开始的话主机A对主机B发送了1,2,3 三个包第一二个包到达了但第三个包此时迷路了，而这个时候主机A掉线断开了连接，当重连后，重新发送了1,2包但是之前发送的3包也到达了B，主机B接受了12包自然认为3是下一个包，于是发生了错误。
	因而，每个连接都要有不同的序号。而这个序号的起始序号是随着时间变化的。
	- 如何确认序号：
	首先主机B监听某个端口处于listen状态
	第一次握手时主机A会发送位码syn=1,以及随机的顺序号码为seq=x的包此时主机A为SYN_SENT状态。
	主机B确认SYN是否为1，如果为1则会向主机B发送syn+ack包,也就是第二次握手位码为ACK=1,确认号码为ack=x+1，来确认序号是否正确，同时也会有SYN=1,以及主机B的顺序号码seq=y。此时主机B处于SYN_RCVD状态
	主机A确认ACK是否为1，以及确认号码是否正确，如果正确则会返回主机B一个ACK包内容为ACK=1，ack=y+1,seq=x+1.此时主机A的状态为ESTABLISHED，当主机B确认ACK为1以及ack正确之后状态也变为ESTABLISHED.
	

一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态。然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 SYN-RCVD 状态。客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后处于 ESTABLISHED 状态，因为它一发一收成功了。服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也一发一收了。

#### 四次挥手

	- 第一次挥手主机A会发送一个FIN包，带有FIN=1,自己的顺序号码seq=p，发送后主机A处于FIN_WAIT1状态。
	- 第二次挥手主机B给主机A返回一个ACK包，有ACK=1,以及ack=p+1，此时主机B处于CLOSED_WAIT状态，主机A处于FIN_WAIT_2状态。等待主机B结束
	- 第三次挥手主机B给主机A发送一个FIN+ACK包，FIN=1,ACK=1，以及seq=q,ack=p+1.主机B进入LAST_ACK状态
	- 第四次挥手主机A给主机B返回一个ACK包，ack=q+1。主机A进入TIME_WAIT状态,主机B收到后CLOSED

在第一次挥手时主机A给主机B发送一个FIN包，告知主机B我要结束了，同时主机A进入FIN_WAIT_1状态，
主机B收到后会返回一个ACK包告知主机A我知道你要结束了,同时自己进入CLOSED_WAIT状态这就是第二次挥手，在这个状态主机B会等待处理完自己的所以事情再结束，
主机A收到主机B返回的ACK包之后，进入FIN_WAIT_2，来等待B的结束，当B结束后会给主机A发送一个FIN+ACK包告知主机A我也要结束了同时进入LAST_ACK状态等待主机A最后的回复，这是第三次挥手。
主机A收到FIN+ACK包知道了主机B也要结束后会返回一个ACK包告诉主机B我知道你要结束了,这个时候主机A会进入TIME_WAIT状态等待网络中主机B所有的包都死亡后再关闭空出端口，而主机B收到主机A发送的ACK包后就直接关闭，这就是第四次挥手

（未完成...）