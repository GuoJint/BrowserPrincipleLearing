## 
 
# 数组
  > 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
  1. 线性表
    > 线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。
    > 每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。
    > 而与它相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。
  2. 连续的内存空间和相同类型的数据
  
    - 相同类型的数据在js的数组总并不适用。在JavaScript中，数组中的每个元素的类型是可以不同的；  
      这是因为JavaScript的弱数据类型决定数组中元素类型可以不同的；  
      因为在JavaScript中，**定义变量的时候不指定其数据类型**，仅仅用一个**var**来表示当前对象是一个变量，至于其是什么类型的不指定，在后面使用的时候可以赋值不同的数值类型。
  
  ***正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”***
  ***这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。***

    - **随机访问**
      计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。  
      当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：  
      `a[i]_address = base_address + i * data_type_size`  
      其中 data_type_size 表示数组中每个元素的大小.

  3. **低效的“插入”和“删除”**
    正常所说数组的插入和删除操作比较低效是因为：
    > 1. 数组要删除某一个值需要根据实际情况去进行前移后面的数据
    > 2. 同样插入也需要进行数据的后移
    > 这两种方式的平均情况复杂度都为O(n)
    **优化点**
    > 插入：我们现在需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2]赋值为 x 即可。最后，数组中的元素如下： a，b，x，d，e，c。
    > ![出错啦](https://static001.geekbang.org/resource/image/3f/dc/3f70b4ad9069ec568a2caaddc231b7dc.jpg)
    > 利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。这个处理思想在**快排**中也会用到。
    > 删除：数组 a[10]中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。
    > 为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。
    > 当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。**标记清除垃圾回收算法的核心思想**

    ***很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。***

  4. 警惕数组的访问越界问题(**面试**)

  5. 容器能否完全替代数组？(**java**)

# 链表
  1. 单链表
    > 我们习惯性地把第一个结点叫作头结点，把最后一个结点叫作尾结点。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。
    > 而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。

# 面试总结
  1. 数组和链表的区别
    **链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)**
    实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。  
    即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。  
    也就是代码实现的算法查找时间复杂度不是O(1),而数组根据下标随机访问的时间复杂度是O(1)。

  2. 警惕数组的访问越界问题
  ```    
    int main(int argc, char* argv[]){
        int i = 0;
        int arr[3] = {0};
        for(; i<=3; i++){
            arr[i] = 0;
            printf("hello world\n");
        }
        return 0;
    }
  ```
  这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world  
  因为，数组大小为 3，a[0]，a[1]，a[2]，而我们的代码因为书写错误，导致 for 循环的结束条件错写为了 i<=3 而非 i<3，所以当 i=3 时，数组 a[3]访问越界。  
  越界后访问到了存储i的地址，并修改了i的值为0切，C语言对这种越界情况并没有做抛出异常的操作所以，会无线循环。  

  > 而在js中数组本来应该是一个连续的内存分配，但是在Javascript中不是连续分配的，而是类似哈希映射的方式存在的。
  > 对于上述的实现方式，熟悉数据结构的同学应该知道，对于读取操作，哈希表的效率并不高，而修改删除的效率比较高。
  > 现在浏览器为了优化其操作，对数组的创建时候的内存分配进行了优化：
  > 对于同构的数组，也就是，数组中元素类型一致，会创建连续的内存分配
  > 对于不同构数组，按照原来的方式创建。
  > 如果你想插入一个异构数据，那么就会重新解构，通过哈希映射的方式创建
  > 为了进一步优化功能的实现，Javascript中出现了ArrayBuffer，它可以创建连续的内存供编程人员使用。

  - ArrayBuffer是创建一块连续的内存，不能直接操作
    通过视图对分配的内存进行读写操作
    显而易见，如果通过ArrayBuffer创建的数组进行遍历操作，速度更快。
  
  3. 为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？(只是有这部分原因，也有历史问题)
    a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：
    `a[k]_address = base_address + k * type_size`
    但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：
    `a[k]_address = base_address + (k-1)*type_size`
    从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令