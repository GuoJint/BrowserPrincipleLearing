### 编译器和解释器
1.编译器和解释器  
按语言的执行流程，可以把语言划分为编译型语言和解释型语言。  
编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。  
而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。  
![编译器](https://static001.geekbang.org/resource/image/4e/81/4e196603ecb78188e99e963e251b9781.png)
![解释器](https://static001.geekbang.org/resource/image/4e/81/4e196603ecb78188e99e963e251b9781.png)  
在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。  
对源代码进行词法分析、语法分析生成抽象语法树(AST)，再通过语义分析生成字节码，在根据字节码进行解释执行。

2.V8 是如何执行一段 JavaScript 代码的
![v8执行流程图](https://static001.geekbang.org/resource/image/1a/ae/1af282bdc4036096c03074da53eb84ae.png)
	-  生成抽象语法树（AST）和执行上下文  
	抽象语法树：可以把 AST 看成代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST。  
	AST 是非常重要的一种数据结构，其中最著名的一个项目是 Babel。  
	Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。  
	
	生成AST的两个阶段：  
	词法分析（分词）：将一行行的源码拆解成一个个 token。token，指的是语法上不可能再分的、最小的单个字符或字符串。  
	语法分析（解析）：将上一步生成的 token 数据，根据语法规则转为 AST。。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。  
	这就是 AST 的生成过程，先分词，再解析。  
	有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。根据代码生成对应的变量环境和词法环境。  
	- 生成字节码  
	解释器根据 AST 生成字节码，并解释执行字节码。  
	机器码虽然效率比字节码效率高，但是机器码占用内存远比字节码要多。
	字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。  
	- 执行代码
	解释器会先解释执行代码，如果有代码重复执行多次，这种就成为热点代码。编译器就会将该字节码编译为更为高效的机器码，
	当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。  
	Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）。  
	![即时编译(JIT)技术](https://static001.geekbang.org/resource/image/66/8a/662413313149f66fe0880113cb6ab98a.png)


总结：V8 依据 JavaScript 代码生成 AST 和执行上下文，再基于 AST 生成字节码，然后通过解释器执行字节码，通过编译器来优化编译字节码。
