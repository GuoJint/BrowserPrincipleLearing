### 消息队列和事件循环
要想在线程运行过程中，能接收并执行新的任务，就需要采用事件循环机制。  
1. 线程的一次行执行
![线程的一次行执行](https://static001.geekbang.org/resource/image/72/bc/72726678ac6604116c1d5dad160780bc.png)
并不是所有的任务都是在执行之前统一安排好的，大部分情况下，新的任务是在线程运行过程中产生的。  
2. 在线程中引入事件循环
![在线程中引入事件循环](https://static001.geekbang.org/resource/image/9e/e3/9e0f595324fbd5b7cd1c1ae1140f7de3.png)
引入了事件循环机制，可以让其在执行过程中接受新的任务.  但还不能接受其他线程发送来的任务仅仅是等待自己产生的任务。
然而其他线程如IO线程会频繁的向渲染主线程发送一些任务让其执行。
3. 消息队列
消息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。  
![队列+循环](https://static001.geekbang.org/resource/image/2a/ab/2ac6bc0361cb4690c5cc83d8abad22ab.png)
	- 添加一个消息队列；
	- IO 线程中产生的新任务添加进消息队列尾部；
	- 渲染主线程会循环地从消息队列头部中读取任务，执行任务。

4. 其他

	- 接受其他进程发送来的任务
	渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程
	- 如何安全退出
	确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。  
	如果设置了，那么就直接中断当前的所有任务，退出线程。  
	- 页面使用单线程的缺点
	第一个问题是如何处理高优先级的任务：采用宏任务与微任务。
	场景：监听DOM变化并执行对应js接口。
	第二个是如何解决单个任务执行时长过久的问题：JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。  
	
消息队列与循环机制小结：
当页面触发事件，后通常都会经过渲染进程的IO线程来将事件封装成任务发送个消息队列。
循环机制去循环执行当前消息队列当中的任务，但DOM变化的即时性，导致不能将dom事件放入消息队列当中。以及(当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。)
所以需要宏任务与微任务，消息队列中的任务为宏任务，当执行当前宏任务时，DOM发生了变化，会把变化任务
添加到当前宏任务的微任务中，并在其执行完后执行微任务。
因为settimeout定时器的特殊性，其也需要一个特殊的队列来进行执行，也就是延迟队列，当创建一个定时器后
会添加到延迟队列当中，并计算其结束时间，当时间结束后将其插入消息队列中，当当前任务执行完后去执行定时器
中的任务，当当前任务执行时间过久的话，也会导致定时器出现延迟执行。
当在执行网络请求时，会把对应的任务交给网络进程来进行执行，最后在将结果通过IPC来返回给消息队列中。

