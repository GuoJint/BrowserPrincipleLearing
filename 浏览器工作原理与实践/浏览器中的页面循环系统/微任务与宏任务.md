### 微任务、宏任务
宏任务：渲染事件（如解析 DOM、计算布局、绘制）；用户交互事件（如鼠标点击、滚动页面、放大缩小等）；JavaScript 脚本执行事件；网络请求完成、文件读写完成事件。
微任务：微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。  

微任务队列：每个宏任务都关联了一个微任务队列。  

产生微任务有两种方式：第一种方式是使用 MutationObserver 监控某个 DOM 节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。  
第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。通过 DOM 节点变化产生  

通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。WHATWG 把执行微任务的时间点称为检查点。  
如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。


结论：
	- 微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。
	- 微任务的执行时长会影响到当前宏任务的时长。
	- 在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。

MutationObserver:采用了“异步 + 微任务”的策略  
通过异步操作解决了同步操作的性能问题；(如果直接加入当前队列并立即执行的话，如果此时DOM变化频繁那么则有可能造成页面卡顿，解决办法：通过异步，当多次改变发生后再生成一次回调函数加入消息队列。)  
通过微任务解决了实时性的问题。





