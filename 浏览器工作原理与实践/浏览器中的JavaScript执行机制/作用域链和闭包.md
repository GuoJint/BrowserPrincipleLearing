### 作用域链和闭包

1. 作用域链
其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。
如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找，我们把这个查找的链条就称为作用域链。

在 JavaScript 执行过程中，其作用域链是由词法作用域决定的。

2. 词法作用域
词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。
词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。

3. 闭包（closure）
在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。

当执行到 bar.setName 方法中的myName = "极客邦"这句代码时，JavaScript 引擎会沿着“当前执行上下文–>foo 函数闭包–> 全局执行上下文”的顺序来查找 myName 变量
https://static001.geekbang.org/resource/image/50/46/50e4ba60fc7e420e83b35b95e379b246.png
可以通过 Scope 来查看实际代码作用域链的情况，这样调试代码也会比较方便。

4. 闭包是怎么回收的
通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。
如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。

总结：
首先，介绍了什么是作用域链，我们把通过作用域查找变量的链条称为作用域链；作用域链是通过词法作用域来确定的，而词法作用域反映了代码的结构。
其次，介绍了在块级作用域中是如何通过作用域链来查找变量的。
最后，又基于作用域链和词法环境介绍了到底什么是闭包。


var->变量提升->js编译执行阶段->变量环境
let,const->块级作用域（当作用域执行完，变量也会被销毁而var不会）->词法环境
作用域->作用域链(查找顺序,词法作用域)->闭包->垃圾回收机制